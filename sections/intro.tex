% 1 page

\subsection{The Non-Relational Concept}
\label{intro-nosql-concept}
% Pontus

\subsection{Key-Value Databases}
\label{intro-kv-db}
% Pontus

\subsection{Document Databases}
\label{intro-doc-db}
% Pontus

\subsection{Graph Databases}
\label{intro-graph-db}
% Alex
% Introduction
A Graph Database takes another approach to database design than other databases. Besides storing information about different entities, it also stores information about the relationship between entities. Graph Databases can be said to be graph-oriented and provide certain properties not found in any other type of database.

% Components
Graph Databases are made up of vertices and edges, also known as nodes and relationships. Both nodes and relationships can have different properties. The properties for nodes are the same as in other databases, e.g. name, and address. But unlike other databases, relationships also have properties, e.g. type or strength. Relationships will also have a direction. The relationships are flexible and new ones can be added without needing to change the database schema. Nodes cannot be removed if they have a relationship, dangling relationships are not allowed.

% Mathematics and computer science
In mathematics, graph theory has existed as a major branch for a long time. The same is true for computer science, which has built upon the graph theory from mathematics. Graph Databases takes advantage of these fields and can provide easy and performant graph traversals. They can also provide path finding between two nodes, and use computer science algorithms for finding all paths or the shortest path.

% Comparison
Relational databases can also simulate a graph through the use of foreign keys and self joins. But with much data the performance decreases significantly with each additional join. There is also no way no make a graph traversal where the depth is unknown beforehand, since the exact number of joins has to be specified in the SQL query. A Graph Database will have persistent relationships, but in a relational database, the relationships have to be recalculated for every query. Other NoSQL solutions will often perform even worse due to the fact that there are no joins available, so creating relationships is harder. Most often, graph traversal needs to be implemented through logic in the application as it is almost impossible to do inside the database.

% Types
There are two major types of Graph Databases: \emph{Resource Description Framework (RDF)} and \emph{Property Graphs}. RDFs provide information based on triples on the form \texttt{entity: attribute :value}. Property Graphs provide a richer model where nodes and relationships can have attributes.

% Implementations
One of the most popular Graph Databases on the market today is \emph{Neo4j}. It is a Property Graph which support billions of nodes, and ACID compliant transactions. Other available databases are \emph{Infinite Graph}, \emph{OrientDB}, and \emph{FlockDB}.

% Query languages
There exists several query languages for Graph Databases, two of the most well known are \emph{Cypher} and \emph{Gremlin}. Cypher was developed for Neo4j, is a declarative query language, and is optimized for graph traversals. Gremlin are procedurally oriented and are available for all graph engines that implement \emph{Blueprints Property Graph}, e.g. Neo4j, Titan, and OrientDB.

% Downsides
One downside of Graph Databases is that their architecture makes it difficult to distribute the database over multiple servers. Since a node can point to any other node, if a node points to a node located on another server, the performance will take a big hit and eliminate the benefits of using a graph-oriented database. Database-wide changes are hard to perform on a Graph Database.

% Upsides
Just like relational databases, a Graph Database is consistent within a single server. Implementations like \emph{Neo4j} is fully ACID compliant. Changes are made through transactions which are either fully successful or completely rolled back. Graph Databases have great performance when traversing a graph and is useful for applications like social graphs, routing, and recommendation engines.

% Scaling
Although sharding is a common scaling technique for other NoSQL databases, this is difficult for a Graph Database since they are relationship-oriented rather than aggregate-oriented, and every node in the system can be related on every other node. However a Graph Database system can be scaled in a few different ways. When all data can fit on a single machine, the read-access can be scaled by adding additional slave nodes. This improves availability but requires that all the data fits on a single machine. There is a master which writes are made to, and that eventually gets pushed to all of the slaves. Slaves can receive a write request, but then first makes the write to the master node, and then itself. The first machine in a cluster becomes the master, and when the master is taken offline, a new master is chosen from the available slaves. Sharding can be done but, like relational databases, must be done from the application side and will probably use domain-specific knowledge.

% Graph Compute Engines
Graph processing algorithms have been incorporated into other database types through \emph{Graph Compute Engines}. The dataset can be resident in any type of database and the Graph Compute Engine provides capabilities such as graph traversals. This allows for better distribution and scaling, but comes with the cost of not being as performant as a true Graph Database. Common Graph Compute Engines are \emph{Apache Giraph}, \emph{GraphX} and \emph{Titan}.

\subsection{Column Databases}
\label{intro-col-db}
% Alex
