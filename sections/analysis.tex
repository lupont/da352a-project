% 4-7 pages
\subsection{Key-value Databases}
\label{analysis-kv-db}

\subsection{Document Databases}
\label{analysis-doc-db}

\subsection{Graph Databases}
\label{analysis-graph-db}

% Cons
One downside of Graph Databases is that the architecture makes it difficult to distribute the database over multiple servers. Since a node can point to any other node, if a node points to a node located on another server, the performance will take a big hit and eliminate the benefits of using a graph-oriented database. Database-wide changes are hard to perform on a Graph Database.

% Pros
Just like relational databases, a Graph Database is consistent within a single server. Implementations like \emph{Neo4j} is fully ACID compliant. Changes are made through transactions which are either fully successful or completely rolled back. Graph Databases have great performance when traversing a graph and is useful for applications like social graphs, routing, and recommendation engines.

In our project, there are a lot of different relationships between nodes that could benefit from being implemented as a Graph Database. One example is the relationship between a performer and a performance. The same performer can have multiple roles in a performance, for example being both the conductor and the soloist. With a Graph Database, this can be modeled with two relationships between two nodes. In a relational database, this would have to be implemented with an extra table between performer and performance where the type of the relationship could be specified. Another way could also be to have multiple instances of the same performer, but each having a different performer type.

The most typical use cases in the application is different types of data retrieval. This includes searching with a keyword, or a specific constraint. For example, this could be, list all of the performances of a piece composed by Brahms. This type of query would require multiple joins in a relational database system, where the Composer, Piece, and Performance tables would have to be joined and filtered. When using a Graph Database, this type of query could be done using graph traversal instead. This could lead to better performance once the database is filling up with data. Although out of scope for this project, future features, that would be very reasonable for this kind of application, could include even more constraints which graph traversal could be benefitial. For example, listing all performances of Beethovens symphonies conducted by Herbert von Karajan.

The biggest downside of using a Graph Database for our project is the difficulty to scale the database. Since the major benefit of a Graph Database is the performance gains of graph traversal, sharding the database and placing different nodes on different servers would most likely eliminate these performance gains. However, there is a possibility to scale the readability of the database by using multiple read-only slave servers. Our project would really take advantage of this, since most of the data in the database are not subject to frequent change. A piece in the database will always be composed by the same composer (unless there is a music historic breakthrough) and the piece will always be part of the same content group. This means that consistency would not be a major problem.

The part of this project where most changes are made to the database are the changes initiated by the user. This includes creating and deleting playlists, and adding and removing performances to or from a playlist. This type of data is user specific, so quick consistency throughout the database is not a big concern. However, losing the changes would be frustrating for user. But this data loss would not result in lost sales or critical data.

A Graph Database could be scaled by sharding the data based on domain-specific knowledge which could be managed in the application layer. This would probably become a bigger challenge as the database grows, since there are no suitable attribute to shard the data by. All performances in the database should be available for all users to put in their playlists, and to search.

\subsection{Column Databases}
\label{analysis-col-db}

% Pros - Column-oriented
A Column Database makes data processing faster when data from the same column needs to be processed from multiple rows. For example aggregate data. This is true for data warehouses and analytics where it is not so common to process all columns of a row at the same time.
Since compression work on localized subsets of data, data stored together by column will more often require less computation to acquire a high compression rate. When the data in a column is sorted, even higher compression can be acquired by storing delta values between columns instead of absolute values.

% Cons - Column-oriented
Just as Column Databases are advantageous when processing data from the same column, they are disadvantageous when processing data from the same row. The different columns of a row are scattered across storage, and requires retrieving from each column store to assemble the row. This can however be slightly improved by using caching and projections.

% Pros - Column-Family Store
Since different rows in a column family can have different columns, it is easy to add and remove a column from a single row. In a relational database, this would require the schema to change and be very hard to do.
Because every node in the cluster are equal, it is very easy to scale a Column-Family Store by simply adding more nodes. This can improve capacity, availability, and read/write performance, depending on how the system is configured.

% Cons - Column-Family Store
The Column-Family store Cassandra does not have transactions, but rather a write is only atomic at the row level. This means that rollbacks must be implemented at the application level, or use an external transaction system like \emph{ZooKeeper}.
Hard to create prototypes with where queries need to change frequently. When changing the queries, the design of the column family will probably have to change as well.

The data model in this project requires many tables where relationships are either optional or unspecified. A performance could have one or one hundred different performers. A performance could be part of an album, and could be part of a content group. Implementing this in a relational database would require an extra linking table between performance and performer. All performances would need to have columns with an optional foreign key for album and content group, which would sometimes unnecessarily take up space in the database. A Column Database could implement the performance table using a column family for performers. The number of columns could vary depending on how many performers a particular piece has. Other fields, like album and content group, could be left empty for the performances which does have this.

A downside with using a Column Database is that the columns for a row is often scattered across multiple disks and servers. In this project, it is very common to list all information about a row everytime it is accessed. For example when playing a performance, the application would display all relevant metadata, like name, length, performers, composers, album, content group, etc. There are not many functions which would benefit from column data being stored contigiously in memory.

A benefit with a Column Database is the ease of scaling it. New nodes can easily be added to the database cluster to extend the storage capabilities, as well as availability. Since this project does not require many frequent changes to the database, it can be configured to have very fast read performance and consistent write performance.
