% 4-7 pages
\subsection{Key-value Databases}
\label{analysis-kv-db}

\subsection{Document Databases}
\label{analysis-doc-db}

\subsection{Graph Databases}
\label{analysis-graph-db}

% Cons
One downside of Graph Databases is that the architecture makes it difficult to distribute the database over multiple servers. Since a node can point to any other node, relationships across servers will reduce the performance of the system. All benefits from faster graph traversal will be eliminated when server routing creates a big performance bottleneck.

% Pros
Just like relational databases, a Graph Database is consistent within a single server. Implementations like \emph{Neo4j} is fully ACID compliant. Changes are made through transactions which are either fully successful or completely rolled back. Graph Databases have great performance when traversing a graph and is useful for applications like social graphs, routing, and recommendation engines.

% Our project - benefits: advanced relationships
In our project, there are a lot of different relationships between data items that could benefit from being implemented as a Graph Database. One example is the relationship between a performer and a performance. The same performer can have multiple roles in a performance, for example being both the conductor and the soloist. With a Graph Database, this can be modeled with two relationships between two nodes, each with a different relationship type. In a relational database, this would have to be implemented with an extra table between performer and performance where the type of the relationship could be specified. Another way could also be to have multiple instances of the same performer, but each having a different performer type.

% Our project - benefits: advanced read queries are fast
The most common use cases in our project is different types of data retrieval. This includes searching with a keyword, or a specific constraint. For example, ``List all performances of any piece composed by Brahms''. This type of query would require multiple joins in a relational database system, where the Composer, Piece, and Performance tables would have to be joined and filtered. When using a Graph Database, this type of query could be done using graph traversal instead. This would provide better performance, especially once the tables become large. The relationships would also always be modeled in the database, whereas in a relational system, they would need to be recalculated for every query. Although out of scope for this project, future features that would be very reasonable for this kind of application could include even more constraints where graph traversal would deliver good performance. For example, ``List all performances of Beethovens symphonies conducted by Herbert von Karajan''.

% Our project - downsides: scalability
The biggest downside of using a Graph Database for our project is the difficulty to scale the database. Since the major benefit of a Graph Database is the performance gains of graph traversal, sharding the database and placing different nodes on different servers would most likely eliminate these performance gains. However, there is a possibility to scale the system for better read-access and availability by using multiple read-only slave servers. Our project would really take advantage of this, since most of the data in the database are not subject to frequent change. A \emph{piece} in the database will always be composed by the same composer (unless there is a music history breakthrough) and the piece will always be part of the same content group. This means that consistency would not be a major problem.

% Our project - where changes are made
The part of this project where most changes are made to the database are the changes initiated by the user. This includes creating and deleting playlists, and adding and removing performances to or from a playlist. This type of data is user specific, so quick consistency throughout the database is not a big concern. However, losing the changes would be frustrating for user. But this data loss would not result in lost sales or critical data.

% Our project - sharding the database
A Graph Database could be scaled by sharding the data based on domain-specific knowledge which could be managed in the application. This would probably become a bigger challenge as the database grows, since there are no suitable attribute in our project to divide the data by. All performances, composers, and performers in the database should be available for all users to search for, list by, or put in their playlists.

\subsection{Column Databases}
\label{analysis-col-db}

% Pros - Column-oriented
A Column-Oriented Database makes data processing faster when data from the same column needs to be processed from multiple rows. This is a typical use case in data warehouses and analytics where it is not so common to process all columns of a row at the same time.
Since compression work on localized subsets of data, data stored together by column will often require less computation to acquire a high compression rate. When the data in a column is sorted, even higher compression can be acquired by storing delta values between columns instead of absolute values.

% Cons - Column-oriented
Just as Column-Oriented Databases are advantageous when processing data from the same column, they are disadvantageous when processing data from the same row. The different columns of a row are scattered in storage, and requires retrieval from each column store to assemble the row. This can however be slightly improved by using caching and projections.

% Pros - Column-Family Store
In a Column-Family Store it is easy to add and remove columns from a single row since different rows can have different columns. In a relational database, this would require the schema to change and be harder to do.
Because every node in the cluster are equal, it is very easy to scale a Column-Family Store by simply adding more nodes. This can improve capacity, availability, and read/write performance, depending on how the system is configured.

% Cons - Column-Family Store
The Column-Family store Cassandra does not have transactions, but rather a write is only atomic at the row level. This means that rollbacks must be implemented at the application level, or by using an external transaction system like \emph{ZooKeeper}.
Column-Family stores also makes it hard to create prototypes where queries need to change frequently. When changing the queries, the design of the column family will probably have to change as well.

% Our project - Pros
The data model in this project requires tables where relationships are either optional or unspecified. For example, a performance could have one or one hundred different performers, and a performance could be part of an album and/or a content group. Implementing this in a relational database would require an extra linking table between performance and performer. All performances would need to have columns with an optional foreign key for album and content group, which would sometimes unnecessarily take up space in the database. A Column Database could implement the performance table using a column family for performers. The number of columns could vary for each row depending on how many performers a particular piece has. Other fields -- album and content group -- could be excluded from the performances which does have this, without it taking up extra space in the database.

% Our project - Cons
A downside with using a Column Database is that the columns for a row is often scattered across multiple disks and servers. In this project, it is very common to list all information about a row every time it is accessed. For example when playing a performance, the application should retrieve and display all relevant metadata, e.g. name, length, performers, composers, album, content group, etc. There are not many functions which would benefit from column data being stored contiguously in memory.

% Our project - Pros
A benefit with with using a Column Database for our project is the ease of scaling it. New nodes can easily be added to the database cluster to extend the storage capabilities, as well as availability. Since this project does not require many frequent changes to the database, it can be configured to have very fast read performance and consistent write performance.
